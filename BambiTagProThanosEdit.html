<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tagpro2</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #222;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/gh/BambiTP/box2dcdn@main/Box2dWeb-2.1.a.3.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.6.6/pixi.min.js"></script>
  
</head>
<body>
<script>

// window listender
window.addEventListener(
    'keydown',
    function(e) {
        if (
            e.key === 'ArrowUp' ||
            e.key === 'ArrowDown' ||
            e.keyCode === 38 ||
            e.keyCode === 40
        ) {
            e.preventDefault();
        }
    }, {
        passive: false
    }
);

var ballID = 0;


var startPhysics = false;

const playerId = 0;
const bombRadius = 0.4 * 7;
const bombStrength = 4;
const gravityEnabled = false;
const pixelsPerTPU = 100;
const viewportWidth = 1280;
const viewportHeight = 800;
const gravityY = gravityEnabled ? -4.9 : 0;
const timestep = 1 / 60;
const quadrantSizePixels = 20;
const gridSizePixels = 40;
const gridSizeTPU = gridSizePixels / pixelsPerTPU;
const convertTpuToPixels = (tpu) => tpu * pixelsPerTPU;
const playerProperties = {
    radius: 0.19,
    density: 1,
    friction: 0.2,
    restitution: 0.02,
    linearDamping: 0.5,
    angularDamping: 0.5,
    accel: 0.025,
    maxSpeed: 2.5,
    jumpVelocity: 4.4,
};
let wallMap = [];
let globalMap = [];
let background,foreground,midground, app,layerContainers;
let playerBody, input; 
let mapWidthPixels = 0;
let mapWidthGrid = 0;
let mapHeightPixels = 0;
let mapHeightGrid = 0;
const frameCache = {};
const sheetCache = {};

var gateArray = [];

var gateSpriteMap = new Map();



var buttonID = 0;

var ballsGettingSuckedOff = new Map();

let jsonData


const balls = [];
const wells = [];


let spectatorMode = false;
const spectatorCamera = {
  x: 0,
  y: 0,
  speed: 10,
  zoom: 1,
};


let zoomLevel = 1;
const zoomStep = 0.025;
const minZoom = 0.3;
const maxZoom = 2;




const keysPressed = {};

window.addEventListener("keydown", (e) => {
  keysPressed[e.key.toLowerCase()] = true;

  if(e.key.toLocaleLowerCase() === "h")
  {
    startPhysics = true;
  }
});

window.addEventListener("keyup", (e) => {
  keysPressed[e.key.toLowerCase()] = false;
});

const   b2Vec2              = Box2D.Common.Math.b2Vec2,
        b2World             = Box2D.Dynamics.b2World,
        b2BodyDef           = Box2D.Dynamics.b2BodyDef,
        b2Body              = Box2D.Dynamics.b2Body,
        b2FixtureDef        = Box2D.Dynamics.b2FixtureDef,
        b2CircleShape       = Box2D.Collision.Shapes.b2CircleShape,
        b2PolygonShape      = Box2D.Collision.Shapes.b2PolygonShape,
        b2ContactListener   = Box2D.Dynamics.b2ContactListener;
        b2AABB              = Box2D.Collision.b2AABB;    // <— add this
let world

const quadrantCoords = {
    "132": [10.5, 7.5],
    "232": [11, 7.5],
    "332": [11, 8],
    "032": [10.5, 8],
    "132d": [0.5, 3.5],
    "232d": [1, 3.5],
    "032d": [0.5, 4],
    "143": [4.5, 9.5],
    "243": [5, 9.5],
    "343": [5, 10],
    "043": [4.5, 10],
    "143d": [1.5, 2.5],
    "243d": [2, 2.5],
    "043d": [1.5, 3],
    "154": [6.5, 9.5],
    "254": [7, 9.5],
    "354": [7, 10],
    "054": [6.5, 10],
    "154d": [9.5, 2.5],
    "254d": [10, 2.5],
    "354d": [10, 3],
    "165": [0.5, 7.5],
    "265": [1, 7.5],
    "365": [1, 8],
    "065": [0.5, 8],
    "165d": [10.5, 3.5],
    "265d": [11, 3.5],
    "365d": [11, 4],
    "176": [1.5, 6.5],
    "276": [2, 6.5],
    "376": [2, 7],
    "076": [1.5, 7],
    "276d": [9, 1.5],
    "376d": [9, 2],
    "076d": [8.5, 2],
    "107": [6.5, 8.5],
    "207": [7, 8.5],
    "307": [7, 9],
    "007": [6.5, 9],
    "207d": [11, 1.5],
    "307d": [11, 2],
    "007d": [10.5, 2],
    "110": [4.5, 8.5],
    "210": [5, 8.5],
    "310": [5, 9],
    "010": [4.5, 9],
    "110d": [0.5, 1.5],
    "310d": [1, 2],
    "010d": [0.5, 2],
    "121": [9.5, 6.5],
    "221": [10, 6.5],
    "321": [10, 7],
    "021": [9.5, 7],
    "121d": [2.5, 1.5],
    "321d": [3, 2],
    "021d": [2.5, 2],
    "142": [1.5, 7.5],
    "242": [2, 7.5],
    "042": [1.5, 8],
    "142d": [10.5, 0.5],
    "242d": [11, 0.5],
    "042d": [10.5, 1],
    "153": [5.5, 6.5],
    "253": [6, 6.5],
    "353": [6, 7],
    "053": [5.5, 7],
    "153d": [5.5, 0.5],
    "253d": [6, 0.5],
    "164": [9.5, 7.5],
    "264": [10, 7.5],
    "364": [10, 8],
    "164d": [0.5, 0.5],
    "264d": [1, 0.5],
    "364d": [1, 1],
    "175": [4.5, 5.5],
    "275": [5, 5.5],
    "375": [5, 6],
    "075": [4.5, 6],
    "275d": [7, 1.5],
    "375d": [7, 2],
    "206": [4.5, 9.5],
    "306": [4.5, 10],
    "006": [3.5, 10],
    "206d": [2, 3.5],
    "306d": [2, 4],
    "006d": [1.5, 4],
    "117": [5.5, 2.5],
    "217": [6, 2.5],
    "317": [6, 4],
    "017": [5.5, 4],
    "317d": [6, 3],
    "017d": [5.5, 3],
    "120": [7.5, 9.5],
    "320": [8, 10],
    "020": [7.5, 10],
    "120d": [9.5, 3.5],
    "320d": [10, 4],
    "020d": [9.5, 4],
    "131": [6.5, 5.5],
    "231": [7, 5.5],
    "331": [7, 6],
    "031": [6.5, 6],
    "131d": [4.5, 1.5],
    "031d": [4.5, 2],
    "141": [7.5, 8.5],
    "241": [8, 8.5],
    "323": [4, 5],
    "041": [7.5, 9],
    "141d": [8.5, 3.5],
    "041d": [8.5, 4],
    "152": [8.5, 7.5],
    "252": [9, 7.5],
    "334": [2, 0],
    "052": [8.5, 8],
    "152d": [3.5, 0.5],
    "252d": [4, 0.5],
    "163": [2, 7.5],
    "263": [3, 7.5],
    "363": [3, 8],
    "045": [9.5, 0],
    "163d": [7.5, 0.5],
    "263d": [8, 0.5],
    "174": [3.5, 8.5],
    "274": [4, 8.5],
    "374": [4, 9],
    "056": [7.5, 5],
    "274d": [3, 3.5],
    "374d": [3, 4],
    "167": [7.5, 6.5],
    "205": [10, 8.5],
    "305": [10, 9],
    "005": [9.5, 9],
    "205d": [2, 0.5],
    "305d": [2, 1],
    "170": [6.5, 7.5],
    "216": [9, 9.5],
    "316": [9, 10],
    "016": [8.5, 10],
    "316d": [10, 5],
    "016d": [9.5, 5],
    "127": [2.5, 9.5],
    "201": [5, 7.5],
    "327": [3, 10],
    "027": [2.5, 10],
    "327d": [2, 5],
    "027d": [1.5, 5],
    "130": [1.5, 8.5],
    "212": [4, 6.5],
    "330": [2, 9],
    "030": [1.5, 9],
    "130d": [9.5, 0.5],
    "030d": [9.5, 1],
    "151": [10.5, 9.5],
    "251": [11, 9.5],
    "324": [0, 7],
    "051": [10.5, 10],
    "151d": [10.5, 4.5],
    "324d": [0, 0],
    "162": [8.5, 10.5],
    "262": [9, 10.5],
    "335": [6, 8],
    "035": [5.5, 8],
    "162d": [3.5, 2.5],
    "262d": [8, 2.5],
    "173": [0.5, 9.5],
    "273": [1, 9.5],
    "373": [1, 10],
    "046": [11.5, 7],
    "046d": [11.5, 0],
    "273d": [1, 4.5],
    "157": [11.5, 8.5],
    "204": [0, 5.5],
    "304": [0, 5],
    "057": [11.5, 9],
    "204d": [0, 4.5],
    "304d": [0, 6],
    "160": [11.5, 7.5],
    "215": [8, 6.5],
    "315": [8, 7],
    "015": [7.5, 7],
    "160d": [2.5, 4.5],
    "315d": [9, 3],
    "171": [5.5, 10.5],
    "271": [6, 10.5],
    "326": [6, 5],
    "026": [5.5, 5],
    "326d": [7, 5],
    "026d": [4.5, 5],
    "137": [3.5, 6.5],
    "202": [0, 7.5],
    "337": [4, 7],
    "037": [3.5, 7],
    "202d": [9, 4.5],
    "037d": [2.5, 3],
    "140": [11.5, 5.5],
    "213": [0, 8.5],
    "313": [0, 9],
    "040": [11.5, 5],
    "140d": [11.5, 4.5],
    "040d": [11.5, 6],
    "161": [9.5, 10.5],
    "261": [10, 10.5],
    "325": [9, 6],
    "025": [8.5, 6],
    "161d": [3.5, 1.5],
    "325d": [4, 1],
    "172": [1.5, 10.5],
    "272": [2, 10.5],
    "336": [3, 6],
    "036": [2.5, 6],
    "036d": [7.5, 1],
    "272d": [8, 1.5],
    "147": [4.5, 7.5],
    "203": [4, 3.5],
    "303": [4, 4],
    "047": [4.5, 8],
    "047d": [8.5, 5],
    "203d": [8, 4.5],
    "150": [7.5, 3.5],
    "214": [7, 7.5],
    "314": [7, 8],
    "050": [7.5, 4],
    "150d": [3.5, 4.5],
    "314d": [3, 5],
    "100": [5.5, 5.5],
    "200": [6, 5.5],
    "300": [6, 6],
    "000": [5.5, 6],
    "100d": [5.5, 8.5],
    "200d": [6, 8.5],
    "300d": [6, 10],
    "000d": [5.5, 10]
};
const wallData= [
  { id: 1,  name: 'Wall',         color: '#787878', image: 'tiles',  wallSolids: 0xff },
  { id: 2,  name: '45TL',         color: '#408050', image: 'tiles',  wallSolids: 0xd2 },
  { id: 3,  name: '45TR',         color: '#405080', image: 'tiles',  wallSolids: 0x4b },
  { id: 4,  name: '45BL',         color: '#807040', image: 'tiles',  wallSolids: 0xb4 },
  { id: 5,  name: '45BR',         color: '#804070', image: 'tiles',  wallSolids: 0x2d },

]


const tileData = [
  { id: 1,  name: 'Wall',         color: '#787878', x: 13, y: 4, image: 'tiles',     hasBackground: false, shape: 'square',   rotation: '0',   size: '40', sensor: false, layer: 'background' },
  { id: 2,  name: '45TL',         color: '#408050', x: 13, y: 4, image: 'tiles',     hasBackground: true,  shape: 'triangle', rotation: '180', size: '40', sensor: false, layer: 'background' },
  { id: 3,  name: '45TR',         color: '#405080', x: 13, y: 4, image: 'tiles',     hasBackground: true,  shape: 'triangle', rotation: '270', size: '40', sensor: false, layer: 'background' },
  { id: 4,  name: '45BL',         color: '#807040', x: 13, y: 4, image: 'tiles',     hasBackground: true,  shape: 'triangle', rotation: '90',  size: '40', sensor: false, layer: 'background' },
  { id: 5,  name: '45BR',         color: '#804070', x: 13, y: 4, image: 'tiles',     hasBackground: true,  shape: 'triangle', rotation: '0',   size: '40', sensor: false, layer: 'background' },
  { id: 6,  name: 'Floor',        color: '#d4d4d4', x: 13, y: 4, image: 'tiles',     hasBackground: false,                                                                layer: 'background' },

  { id: 7,  name: 'YellowFlag',   color: '#808000', x: 13, y: 1, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 8,  name: 'RedFlag',      color: '#ff0000', x: 14, y: 1, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 9,  name: 'BlueFlag',     color: '#0000ff', x: 15, y: 1, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 10, name: 'Spike',        color: '#373737', x: 12, y: 0, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '14', sensor: true,  layer: 'background' },
  { id: 11, name: 'GravityWell',  color: '#202020', x: 0, y: 0, image: 'gravitywell',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '2800', sensor: true,  layer: 'midground' }, // fix size
  { id: 12, name: 'YellowPotato', color: '#656500', x: 14, y: 6, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 13, name: 'RedPotato',    color: '#ff8080', x: 14, y: 7, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 14, name: 'BluePotato',   color: '#8080ff', x: 14, y: 8, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 15, name: 'RedGoal',      color: '#b90000', x: 14, y: 5, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 16, name: 'BlueGoal',     color: '#190094', x: 15, y: 5, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 17, name: 'RedTile',      color: '#dcbaba', x: 14, y: 4, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 18, name: 'BlueTile',     color: '#bbb8dd', x: 15, y: 4, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 19, name: 'YellowTile',   color: '#dcdcba', x: 13, y: 5, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 20, name: 'Bomb',         color: '#ff8000', x: 12, y: 1, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 21, name: 'Button',       color: '#b97a57', x: 13, y: 6, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '8',  sensor: true,  layer: 'background' },
  { id: 22, name: 'EmptyGate',    color: '#007500', x: 12, y: 3, image: 'tiles',     hasBackground: false, shape: 'square',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 23, name: 'GreenGate',    color: '#007500', x: 13, y: 3, image: 'tiles',     hasBackground: false, shape: 'square',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 24, name: 'RedGate',      color: '#007500', x: 14, y: 3, image: 'tiles',     hasBackground: false, shape: 'square',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 25, name: 'BlueGate',     color: '#007500', x: 15, y: 3, image: 'tiles',     hasBackground: false, shape: 'square',   rotation: '0',   size: '40', sensor: true,  layer: 'background' },
  { id: 26, name: 'PupJJ',        color: '#00ff00', x: 12, y: 4, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '40', sensor: true,  layer: 'midground' },
  { id: 27, name: 'PupRB',        color: '#00ff00', x: 12, y: 5, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 28, name: 'PupTP',        color: '#00ff00', x: 12, y: 6, image: 'tiles',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 29, name: 'Portal',       color: '#cac000', x: 0,  y: 0, image: 'portal',    hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 30, name: 'RedPortal',    color: '#cc3300', x: 0,  y: 0, image: 'redportal', hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 31, name: 'BluePortal',   color: '#0066cc', x: 0,  y: 0, image: 'blueportal',hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 32, name: 'Boost',        color: '#ffff00', x: 0,  y: 0, image: 'boost',     hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 33, name: 'RedBoost',     color: '#ff7373', x: 0,  y: 0, image: 'redboost',  hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 34, name: 'BlueBoost',    color: '#7373ff', x: 0,  y: 0, image: 'blueboost', hasBackground: true,  shape: 'circle',   rotation: '0',   size: '15', sensor: true,  layer: 'midground' },
  { id: 35, name: 'RedBall',  color: '' ,    x: 14, y: 0,    image: 'tiles' },
  { id: 36, name: 'BlueBall', color: '',    x: 15, y: 0,    image: 'tiles' }

];

const player = [
  { id: 35, name: 'Player', x: 14, y: 0, image: 'tiles',},
];
const sheetUrls = {
  tiles:      'https://static.koalabeast.com/textures/musclescupgradients/tiles.png',
  boost:      'https://static.koalabeast.com/textures/musclescupgradients/speedpad.png',
  redboost:   'https://static.koalabeast.com/textures/musclescupgradients/speedpadred.png',
  blueboost:  'https://static.koalabeast.com/textures/musclescupgradients/speedpadblue.png',
  portal:     'https://static.koalabeast.com/textures/musclescupgradients/portal.png',
  redportal:  'https://static.koalabeast.com/textures/musclescupgradients/portalred.png',
  blueportal: 'https://static.koalabeast.com/textures/musclescupgradients/portalblue.png',
  gravitywell: 'https://static.koalabeast.com/images/gravitywell.png'
};




function wallSolidsAt(col, row) {
    if (col < 0 || row < 0 || row >= wallMap.length || col >= wallMap[0].length) return 0;
    return wallMap[row][col];
}

function drawWallTile(col, row) {
    const solids = wallMap[row][col];
    if (!solids) return;
    for (let q = 0; q < 4; q++) {
        const mask = (solids >> (q << 1)) & 3;
        if (mask === 0) continue;
        const cornerX = col + ((q & 2) === 0 ? 1 : 0);
        const cornerY = row + (((q + 1) & 2) === 0 ? 0 : 1);
        let aroundCorner =
            (wallSolidsAt(cornerX, cornerY) & 0xc0) |
            (wallSolidsAt(cornerX - 1, cornerY) & 0x03) |
            (wallSolidsAt(cornerX - 1, cornerY - 1) & 0x0c) |
            (wallSolidsAt(cornerX, cornerY - 1) & 0x30);
        aroundCorner |= (aroundCorner << 8);
        const startDirection = q * 2 + 1;
        let cwSteps = 0;
        while (cwSteps < 8 && (aroundCorner & (1 << (startDirection + cwSteps)))) {
            cwSteps++;
        }
        let ccwSteps = 0;
        while (ccwSteps < 8 && (aroundCorner & (1 << (startDirection + 7 - ccwSteps)))) {
            ccwSteps++;
        }
        const hasChip = (mask === 3 && (((solids | (solids << 8)) >> ((q + 2) << 1)) & 3) === 0);
        let solidStart, solidEnd;
        if (cwSteps === 8) {
            solidStart = solidEnd = 0;
        } else {
            solidEnd = (startDirection + cwSteps + 4) % 8;
            solidStart = (startDirection - ccwSteps + 12) % 8;
        }
        const key = `${q}${solidStart}${solidEnd}${hasChip ? "d" : ""}`;
        const coords = quadrantCoords[key] || [5.5, 5.5];
        let destX = col * gridSizePixels;
        let destY = row * gridSizePixels;
        if (q === 0) destX += quadrantSizePixels;
        else if (q === 1) {
            destX += quadrantSizePixels;
            destY += quadrantSizePixels;
        } else if (q === 2) destY += quadrantSizePixels;
        const srcX = coords[0] * 40;
        const srcY = coords[1] * 40;
        drawTile(key, destX, destY, background)
    }
}

const colorToId = tileData.reduce((m, {
    color,
    id
}) => {
    m.set(color.toLowerCase(), id);
    return m;
}, new Map());









async function makeMapArray(mapId) {
    wallMap = [];
    globalMap = [];
    const corsProxy = "https://cors.bambitp.workers.dev/?url=";
    const url = corsProxy + `https://fortunatemaps.herokuapp.com/png/${mapId}.png`;
    jsonData = await loadJson(corsProxy +`https://fortunatemaps.herokuapp.com/json/${mapId}.json`);
    const img = new Image();

    img.crossOrigin = 'anonymous';
    img.src = url;
   await new Promise((resolve, reject) => {
    img.onload = resolve;
    img.onerror = () => reject(new Error("Image failed to load"));
});
    const imageWidth = img.naturalWidth;
    const imageHeight = img.naturalHeight;
    const canvas2 = document.createElement('canvas');
    canvas2.width = imageWidth;
    canvas2.height = imageHeight;
    const ctx = canvas2.getContext('2d');
    ctx.drawImage(img, 0, 0);
    const data = ctx.getImageData(0, 0, imageWidth, imageHeight)
        .data;
    const wallLookup = wallData.reduce((lookup, tile) => {
        lookup[tile.color.toLowerCase()] = tile.wallSolids;
        return lookup;
    }, {});

    for (let y = 0; y < canvas2.height; y++) {
        wallMap[y] = [];
        for (let x = 0; x < canvas2.width; x++) {
            const idx = (y * canvas2.width + x) * 4;
            const r = data[idx],
                g = data[idx + 1],
                b = data[idx + 2],
                a = data[idx + 3];
            const hex = ('#' + rgbToHex(r, g, b))
                .toLowerCase();
            wallMap[y][x] = (a === 0) ?
                0 :
                (wallLookup.hasOwnProperty(hex) ?
                    wallLookup[hex] :
                    0);
        }
    }


    globalMap = Array.from({
        length: imageHeight
    }, (_, y) => {
        const row = new Array(imageWidth);
        for (let x = 0; x < imageWidth; x++) {
            const i = (y * imageWidth + x) * 4;
            const hex = (
                    '#' +
                    data[i + 0].toString(16)
                    .padStart(2, '0') +
                    data[i + 1].toString(16)
                    .padStart(2, '0') +
                    data[i + 2].toString(16)
                    .padStart(2, '0')
                )
                .toLowerCase();
        if (hex === '#007500') {
         row[x] = determineGateId(x, y, jsonData);
                               } 
        else {
         row[x] = colorToId.get(hex) || 0;
}        }
        return row;
    });

    //console.log(globalMap);
    //console.log(wallMap);
}

function determineGateId(x, y, json) {
  const key = `${x},${y}`;
  const field = json.fields?.[key];

  if (field && field.defaultState) {
    switch (field.defaultState.toLowerCase()) {
      case 'green':
        return 23;
      case 'red':
        return 24;
      case 'blue':
        return 25;
      default:
        return 22;
    }
  }

  return 22;
}

async function loadJson(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
}


function rgbToHex(r, g, b) {
    return ((1 << 24) + (r << 16) + (g << 8) + b)
        .toString(16)
        .slice(1);
}


function drawTilesLoop() {
  for (let y = 0; y < mapHeightGrid; y++) {
    for (let x = 0; x < mapWidthGrid; x++) {
      const tileId = globalMap[y][x];
      const tile   = tileData.find(t => t.id === tileId);
       if (!tile) {
        continue;
      }
      drawTile(tileId, x * gridSizePixels, y * gridSizePixels, tile.layer);
      drawWallTile(x, y);
    }
  }
}

async function redrawBackgroundAsOneTexture() {
    const renderTex = PIXI.RenderTexture.create({ width: mapWidthPixels, height: mapHeightPixels });
    app.renderer.render(background, { renderTexture: renderTex });
    const canvas = app.renderer.extract.canvas(renderTex);
    const dataurl = canvas.toDataURL('image/png');
    const img = new Image();
    img.src = dataurl;
    const mapImage = await PIXI.Assets.load(img);
    const redraw = new PIXI.Sprite(mapImage);
    background.removeChildren();
    background.addChild(redraw);
}

async function initPixi() {
      app = new PIXI.Application();
         await app.init({
       width: viewportWidth,
       height: viewportHeight,
    });
    document.body.appendChild(app.canvas);      
    background = new PIXI.Container();
    midground = new PIXI.Container();
    foreground = new PIXI.Container();  
    layerContainers = { background, midground, foreground };
    app.stage.addChild(background);
    app.stage.addChild(midground);
    app.stage.addChild(foreground);

}
async function start(mapId) {
    initPhysics()
    await makeMapArray(mapId);
    const rows = globalMap.length;
    if (!rows) {
        console.error("makeMapArray() returned an empty map!");
        return;
    }
    const cols = globalMap[0].length;
    mapHeightPixels = rows * 40;
    mapWidthPixels = cols * 40;

    spectatorCamera.x = mapWidthPixels/2;
    spectatorCamera.y = mapHeightPixels/2;
    mapHeightGrid = rows;
    mapWidthGrid = cols;
    await initPixi();
    await cacheAllFrames();
    await cacheAllQuadrants();
    await drawTilesLoop();
    await redrawBackgroundAsOneTexture();


const centerX = (mapWidthGrid * gridSizeTPU) / 2;
const centerY = (mapHeightGrid * gridSizeTPU) / 2;
// [-1, 0, 1].forEach(offset => {
//   createBall(centerX + offset * 0.5, centerY, "blue");
//   createBall(centerX + offset * 0.5, centerY, "red");

// });    



//player


  createBall(centerX + 30 * gridSizeTPU, centerY, "red");


createBall(3 * gridSizeTPU + gridSizeTPU/2, 1 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(3 * gridSizeTPU + gridSizeTPU/2, 5 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(3 * gridSizeTPU + gridSizeTPU/2, 9 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(3 * gridSizeTPU + gridSizeTPU/2, 13 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(3 * gridSizeTPU + gridSizeTPU/2, 17 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(3 * gridSizeTPU + gridSizeTPU/2, 21 * gridSizeTPU + gridSizeTPU/2, "red");

createBall(16 * gridSizeTPU + gridSizeTPU/2, 1 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(16 * gridSizeTPU + gridSizeTPU/2, 5 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(16 * gridSizeTPU + gridSizeTPU/2, 9 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(16 * gridSizeTPU + gridSizeTPU/2, 13 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(16 * gridSizeTPU + gridSizeTPU/2, 17 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(16 * gridSizeTPU + gridSizeTPU/2, 21 * gridSizeTPU + gridSizeTPU/2, "red");


createBall(29 * gridSizeTPU + gridSizeTPU/2, 1 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(29 * gridSizeTPU + gridSizeTPU/2, 5 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(29 * gridSizeTPU + gridSizeTPU/2, 9 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(29 * gridSizeTPU + gridSizeTPU/2, 13 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(29 * gridSizeTPU + gridSizeTPU/2, 17 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(29 * gridSizeTPU + gridSizeTPU/2, 21 * gridSizeTPU + gridSizeTPU/2, "red");

createBall(42 * gridSizeTPU + gridSizeTPU/2, 1 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(42 * gridSizeTPU + gridSizeTPU/2, 5 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(42 * gridSizeTPU + gridSizeTPU/2, 9 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(42 * gridSizeTPU + gridSizeTPU/2, 13 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(42 * gridSizeTPU + gridSizeTPU/2, 17 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(42 * gridSizeTPU + gridSizeTPU/2, 21 * gridSizeTPU + gridSizeTPU/2, "red");


createBall(3 * gridSizeTPU + gridSizeTPU/2, 28 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(3 * gridSizeTPU + gridSizeTPU/2, 41 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(3 * gridSizeTPU + gridSizeTPU/2, 54 * gridSizeTPU + gridSizeTPU/2, "red");


createBall(16 * gridSizeTPU + gridSizeTPU/2, 28 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(16 * gridSizeTPU + gridSizeTPU/2, 41 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(16 * gridSizeTPU + gridSizeTPU/2, 54 * gridSizeTPU + gridSizeTPU/2, "red");



createBall(29 * gridSizeTPU + gridSizeTPU/2, 28 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(29 * gridSizeTPU + gridSizeTPU/2, 41 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(29 * gridSizeTPU + gridSizeTPU/2, 54 * gridSizeTPU + gridSizeTPU/2, "red");


createBall(42 * gridSizeTPU + gridSizeTPU/2, 28 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(42 * gridSizeTPU + gridSizeTPU/2, 41 * gridSizeTPU + gridSizeTPU/2, "red");
createBall(42 * gridSizeTPU + gridSizeTPU/2, 54 * gridSizeTPU + gridSizeTPU/2, "red");
// createBall(3 * gridSizeTPU + gridSizeTPU/2, centerY - 17 * gridSizeTPU, "red");
// createBall(3 * gridSizeTPU + gridSizeTPU/2, centerY - 13 * gridSizeTPU, "red");
// createBall(3 * gridSizeTPU + gridSizeTPU/2, centerY - 10 * gridSizeTPU, "red");
// createBall(3 * gridSizeTPU + gridSizeTPU/2, centerY - 2 * gridSizeTPU, "red");


// createBall(centerX - 24 * gridSizeTPU, centerY - 15 * gridSizeTPU, "red");
// createBall(centerX - 24 * gridSizeTPU, centerY - 19 * gridSizeTPU, "red");
// createBall(centerX - 24 * gridSizeTPU, centerY + 13 * gridSizeTPU, "red");




// createBall(centerX - 10 * gridSizeTPU, centerY - 2*gridSizeTPU, "red");
// createBall(centerX - 10 * gridSizeTPU, centerY - 11 * gridSizeTPU, "red");

// createBall(centerX - 10 * gridSizeTPU, centerY - 15 * gridSizeTPU, "red");

// createBall(centerX - 10 * gridSizeTPU, centerY - 19 * gridSizeTPU, "red");


// createBall(centerX + 5 * gridSizeTPU, centerY - 19 * gridSizeTPU, "red");





gameLoop();
    createAllPhysicsBodies();
}

function update() {

  applyMovement();       // (you’ll need to decide which ball this moves)
  
  applyGravWell();
  world.Step(timestep, 8, 3);
  world.ClearForces();
updateCamera();
  
  syncAllBalls();

}
function syncGraphics() {
  if (balls.length === 0) return;

  // Example: follow the first ball
  const { body } = balls[playerId];
  const p = body.GetPosition();
  const px = convertTpuToPixels(p.x);
  const py = convertTpuToPixels(p.y);

  app.stage.position.set(
    app.renderer.screen.width  / 2 - px,
    app.renderer.screen.height / 2 - py
  );
}

function updateCamera() {
      if (keysPressed["="]) zoomLevel+= zoomStep;
    if (keysPressed["-"]) zoomLevel-= zoomStep;
app.stage.scale.set(zoomLevel);
  if (spectatorMode) {
    if (keysPressed["i"]) spectatorCamera.y -= spectatorCamera.speed;
    if (keysPressed["k"]) spectatorCamera.y += spectatorCamera.speed;
    if (keysPressed["j"]) spectatorCamera.x -= spectatorCamera.speed;
    if (keysPressed["l"]) spectatorCamera.x += spectatorCamera.speed;
      
     app.stage.position.set(-spectatorCamera.x *zoomLevel  + app.renderer.width / 2, -spectatorCamera.y*zoomLevel + app.renderer.height / 2);
  } else {
syncGraphics();
  }
}


function syncGraphics() {
  if (balls.length === 0) return;

  // Example: follow the first ball
  const { body } = balls[playerId];
  const p = body.GetPosition();
  const px = convertTpuToPixels(p.x);
  const py = convertTpuToPixels(p.y);

  app.stage.position.set(
    (app.renderer.screen.width)  / 2 - (px * zoomLevel),
    (app.renderer.screen.height)/ 2 - (py * zoomLevel)
  );
}



function gameLoop(){
    app.ticker.add(() => {
        update();

    });

}

async function cacheAllQuadrants() {
    const imageKey = 'tiles';
    const url = sheetUrls[imageKey];
    if (!sheetCache[url]) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        const imgLoaded = new Promise((res, rej) => {
            img.onload = () => res();
            img.onerror = (e) => rej(e);
        });
        img.src = url;
        await imgLoaded;
        sheetCache[url] = {
            source: new PIXI.ImageSource({
                resource: img
            }),
            img,
        };
    }
    const {
        source
    } = sheetCache[url];
    for (const [quadId, [sheetCol, sheetRow]] of Object.entries(quadrantCoords)) {
        const frame = new PIXI.Rectangle(
            sheetCol * gridSizePixels,
            sheetRow * gridSizePixels,
            quadrantSizePixels,
            quadrantSizePixels
        );
        frameCache[quadId] = new PIXI.Texture({
            source,
            frame
        });
    }
}


async function cacheAllFrames() {
    for (const {
            image
        }
        of tileData) {
        const url = sheetUrls[image];
        if (!sheetCache[url]) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            const imgLoaded = new Promise((res, rej) => {
                img.onload = () => res();
                img.onerror = (e) => rej(e);
            });
            img.src = url;
            await imgLoaded;
            const source = new PIXI.ImageSource({
                resource: img
            });
            sheetCache[url] = {
                source,
                img
            };
        }
    }
    for (const {
            id,
            x: sheetCol,
            y: sheetRow,
            image
        }
        of tileData) {
        const {
            source,
            img
        } = sheetCache[sheetUrls[image]];
        const frame = new PIXI.Rectangle(
            sheetCol * gridSizePixels,
            sheetRow * gridSizePixels,
            gridSizePixels,
            gridSizePixels
        );
        frameCache[id] = new PIXI.Texture({
            source,
            frame
        });
    }
}

function drawTile(id, x, y, layer) {
  const container = layerContainers[layer] || layerContainers.background;
  const tex = frameCache[id];
 // console.log(frameCache);
    if (!tex) {
        return null;
    }

    const tile = tileData.find(t => t.id === id);

    if (tile && tile.hasBackground) {
        const bgTex = frameCache[6];
        if (bgTex) {
            const bgSprite = new PIXI.Sprite(bgTex);
            bgSprite.x = x;
            bgSprite.y = y;
              const gridX = Math.floor(x / gridSizePixels);
            const gridY = Math.floor(y / gridSizePixels);
            bgSprite._gridKey = `${gridX},${gridY}`
            background.addChild(bgSprite);
        } 
    }

    const sprite = new PIXI.Sprite(tex);
    sprite.x = x;
    sprite.y = y;
    const gridX = Math.floor(x / gridSizePixels);
    const gridY = Math.floor(y / gridSizePixels);
    sprite._gridKey = `${gridX},${gridY}`
    container.addChild(sprite);
    return sprite;
}


function removeTile(sprite) {

  try {
sprite.parent.removeChild(sprite);
  }

  catch(e){
    console.log(e);
  }
}




//Planck Code

 function initPhysics() {
  world = new b2World(new b2Vec2(0, gravityY));
  world.SetContactListener(createContactListener());
}

function createContactListener() {
  const listener = new b2ContactListener();

  listener.BeginContact = contact => {
    handleBoostContact(contact);
    handleBombContact(contact);
    handleButtonContact(contact);
    //handleGravWellContact(contact)
  };

  listener.EndContact = contact => {
    //handleBoostContact(contact);
    //handleBombContact(contact);
    //handleButtonContact(contact);
    handleButtonEndContact(contact);
   // handleGravWellEndContact(contact)
  };

  //listener.EndContact  = () => {};
  listener.PreSolve    = () => {};
  listener.PostSolve   = () => {};

  return listener;
}


function handleGravWellContact(contact)
{
  //console.log("GRAV");
  const fA = contact.GetFixtureA(); //fixtureA
  const fB = contact.GetFixtureB();
  const dA = fA.GetUserData();
  const dB = fB.GetUserData();

  let playerBody = null;
  var gravBody = null;
var playerFixture = null
  if (dA?.tile === 'GravityWell' && dB?.type === 'ball') {
    //bombBody    = fA.GetBody();
    playerData = dB;
    playerFixture = fB;
    gravBody = fA.GetBody().GetPosition();


  }
  else if (dB?.tile === 'GravityWell' && dA?.type === 'ball') {
    //bombBody    = fB.GetBody();
    playerData = dA;
    playerFixture = fA;
    gravBody = fB.GetBody().GetPosition();
  }

  else return;

  //console.log(gravBody);
  ballsGettingSuckedOff.set(playerFixture.GetBody(), gravBody);
}




function handleBombContact(contact) {
  const fA = contact.GetFixtureA();
  const fB = contact.GetFixtureB();
  const dA = fA.GetUserData();
  const dB = fB.GetUserData();

  // find bomb vs ball
  let bombBody = null, hitBallBody = null;

  if (dA?.tile === 'Bomb' && dB?.type === 'ball') {
    bombBody    = fA.GetBody();
    hitBallBody = fB.GetBody();
  }
  else if (dB?.tile === 'Bomb' && dA?.type === 'ball') {
    bombBody    = fB.GetBody();
    hitBallBody = fA.GetBody();
  }
  else return;

  // trigger explosion centered on bomb, which will push all nearby dynamics
  triggerExplosion(bombBody, bombStrength, bombRadius);
}



function handleBoostContact(contact) {
  const fA = contact.GetFixtureA();
  const fB = contact.GetFixtureB();
  const dA = fA.GetUserData();
  const dB = fB.GetUserData();

  // find boost vs ball
  let hitBallBody = null;

  if (dA?.tile === 'Boost' && dB?.type === 'ball') {
    hitBallBody = fB.GetBody();
  }
  else if (dB?.tile === 'Boost' && dA?.type === 'ball') {
    hitBallBody = fA.GetBody();
  }
  else return;

  // apply boost only to that ball
  applyBoostVelocity(hitBallBody);
}


function handleButtonContact(contact)
{
  const fixtureA = contact.GetFixtureA();
  const fixtureB = contact.GetFixtureB();
  const dataA = fixtureA.GetUserData();
  const dataB = fixtureB.GetUserData();

  let theButtonData = null;

  if (dataA?.tile === 'Button' && dataB?.type === 'ball') {
    theButtonData = dataA;
  }
  else if (dataB?.tile === 'Button' && dataA?.type === 'ball') {
    theButtonData = dataB;
  }
  else return;

  triggerButton(theButtonData)

}


function handleButtonEndContact(contact)
{
  //console.log("HELLO");
  const fixtureA = contact.GetFixtureA();
  const fixtureB = contact.GetFixtureB();
  const dataA = fixtureA.GetUserData();
  const dataB = fixtureB.GetUserData();

  let theButtonData = null;

  if (dataA?.tile === 'Button' && dataB?.type === 'ball') {
    theButtonData = dataA;
  }
  else if (dataB?.tile === 'Button' && dataA?.type === 'ball') {
    theButtonData = dataB;
  }
  else return;

  triggerButtonOff(theButtonData)

}



function handleGravWellEndContact(contact)
{
 // console.log("GRAV");
  const fA = contact.GetFixtureA(); //fixtureA
  const fB = contact.GetFixtureB();
  const dA = fA.GetUserData();
  const dB = fB.GetUserData();

  let playerBody = null;
  var gravBody = null;
var playerFixture = null
  if (dA?.tile === 'GravityWell' && dB?.type === 'ball') {
    //bombBody    = fA.GetBody();
    playerData = dB;
    playerFixture = fB;
    gravBody = fA.GetBody().GetPosition();


  }
  else if (dB?.tile === 'GravityWell' && dA?.type === 'ball') {
    //bombBody    = fB.GetBody();
    playerData = dA;
    playerFixture = fA;
    gravBody = fB.GetBody().GetPosition();
  }

  else return;

//  console.log(gravBody);
  //ballsGettingSuckedOff.set(playerFixture.GetBody(), gravBody);
  ballsGettingSuckedOff.delete(playerFixture.GetBody());
}







function triggerExplosion(bombBody, strength, radius) {
  const center = bombBody.GetPosition();
  const aabb = new b2AABB();
  aabb.lowerBound.Set(center.x - radius, center.y - radius);
  aabb.upperBound.Set(center.x + radius, center.y + radius);

  // query all fixtures in that box
  world.QueryAABB(function(fixture) {
    const body = fixture.GetBody();
    if (body.GetType() !== Box2D.Dynamics.b2Body.b2_dynamicBody) {
      return true; // keep going
    }

    const pos = body.GetPosition();
    const dx = pos.x - center.x;
    const dy = pos.y - center.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist > 0 && dist < radius) {
      const boost = strength * (radius - dist);
      const dir = new b2Vec2(dx / dist, dy / dist);

      const vel = body.GetLinearVelocity().Copy();
      vel.x += dir.x * boost;
      vel.y += dir.y * boost;
      body.SetLinearVelocity(vel);
    }

    return true; // continue query
  }, aabb);
}


function triggerExplosionButton(arrayLocation, strength, radius) {
  //const center = bombBody.GetPosition();

 // console.log(arrayLocation);

 if(startPhysics)
 {
  const mapLocation = {x: arrayLocation.pos.x*  gridSizeTPU + gridSizeTPU / 2, y: arrayLocation.pos.y* gridSizeTPU + gridSizeTPU / 2}

   // console.log(mapLocation);
  const aabb = new b2AABB();
  aabb.lowerBound.Set(mapLocation.x - radius, mapLocation.y - radius);
  aabb.upperBound.Set(mapLocation.x + radius, mapLocation.y + radius);

  // query all fixtures in that box
  world.QueryAABB(function(fixture) {
    const body = fixture.GetBody();
    if (body.GetType() !== Box2D.Dynamics.b2Body.b2_dynamicBody) {
      return true; // keep going
    }

    const pos = body.GetPosition();
    const dx = pos.x - mapLocation.x ;
    const dy = pos.y - mapLocation.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist > 0 && dist < radius) {
      const boost = strength * (radius - dist);
      const dir = new b2Vec2(dx / dist, dy / dist);

      const vel = body.GetLinearVelocity().Copy();
      vel.x += dir.x * boost;
      vel.y += dir.y * boost;
      body.SetLinearVelocity(vel);
    }

    return true; // continue query
  }, aabb);

}
}




function triggerButton(buttonData)
{
  //console.log(buttonData)
  var toggleArray = buttonData.toggles;
 // console.log(toggleArray[0].pos)
 // console.log(globalMap[toggleArray[0].pos.y][toggleArray[0].pos.x]);
var tempSpritesArray = [];
  for(var i = 0; i < toggleArray.length; i++)
  {
    if(globalMap[toggleArray[i].pos.y][toggleArray[i].pos.x] === 20)
    {
      //console.log("BOOOOOM");
       triggerExplosionButton(toggleArray[i], bombStrength, bombRadius);
    }

    else if(globalMap[toggleArray[i].pos.y][toggleArray[i].pos.x] === 22)
    {

      tempSpritesArray.push(drawTile(24, toggleArray[i].pos.x * gridSizePixels, toggleArray[i].pos.y * gridSizePixels, 'midground'));
      
      
      //console.log("GATE NOISES");


    }
  }

 gateSpriteMap.set(buttonData.bID, tempSpritesArray);

}

function triggerButtonOff(buttonData)
{
  //console.log(buttonData)
  var toggleArray = buttonData.toggles;
  //console.log(toggleArray[0].pos)
  //console.log(globalMap[toggleArray[0].pos.y][toggleArray[0].pos.x]);
var tempSpritesArray = gateSpriteMap.get(buttonData.bID);

  for(var i = 0; i < tempSpritesArray.length; i++)
{

    removeTile(tempSpritesArray[i]);
}

gateSpriteMap.delete(buttonData.bID);


}



function applyBoostVelocity(body) {
  const v = body.GetLinearVelocity();
  const mag = Math.hypot(v.x, v.y);
  if (mag > 0) {
    const scale = playerProperties.maxSpeed * 2.9 / mag;
    body.SetLinearVelocity(new b2Vec2(v.x * scale, v.y * scale));
  } else {
    body.SetLinearVelocity(new b2Vec2(playerProperties.maxSpeed * 2, 0));
  }
}



function findToggles(x,y,json)
{
  //console.log(json)
  const key = `${x},${y}`;
  const toggleArray = json.switches?.[key].toggle;
  return toggleArray;

}



function createPhysicsBody(x, y, tile, size, shape, sensor, rotation) {
  const meterSize = (size / 100);

  const bx = x * gridSizeTPU + gridSizeTPU / 2;
  const by = y * gridSizeTPU + gridSizeTPU / 2;

  const bodyDef = new b2BodyDef();
  bodyDef.type     = b2Body.b2_staticBody;
  bodyDef.position = new b2Vec2(bx, by);
  bodyDef.angle    = rotation || 0;

  const body = world.CreateBody(bodyDef);

  const fixDef = new b2FixtureDef();
  fixDef.isSensor = !!sensor;

  if (shape === 'circle') {
    fixDef.shape = new b2CircleShape(meterSize);
  }
  else if (shape === 'square') {
    const half = meterSize / 2;
    fixDef.shape = new b2PolygonShape();
    fixDef.shape.SetAsBox(half, half);
  }
  else if (shape === 'triangle') {
    const half = meterSize / 2;
    const verts = [
      new b2Vec2( +half, +half ),
      new b2Vec2( -half, +half ),
      new b2Vec2( +half, -half ),
    ];
    fixDef.shape = new b2PolygonShape();
    fixDef.shape.SetAsArray(verts, verts.length);
  }
  else {
    return;
  }

  const fixture = body.CreateFixture(fixDef);

  // Attach the tile index and its grid coordinates as userData
  var buttonToggles = null;
  var tbID = null
if(tile === "Button")
{
  buttonToggles = findToggles(x, y, jsonData)

  gateArray.push([]);
  //console.log(buttonToggles);
  tbID = buttonID;
  console.log(tbID);
  buttonID++;
}

if(tile === "GravityWell")
{
  wells.push(body);
}




  fixture.SetUserData({
    tile: tile,
    gridX: x,
    gridY: y,
    toggles: buttonToggles,
    bID: tbID
  });

  return body;
}


    window.addEventListener('keydown', (e) => handleKey(e, true));
    window.addEventListener('keyup', (e) => handleKey(e, false));


    window.addEventListener("keydown", (e) => {
  if (e.key.toLowerCase() === "c") {
    spectatorMode = !spectatorMode;
    console.log("Spectator Mode:", spectatorMode ? "ON" : "OFF");
  }
});

function handleKey(e, isDown) {
  switch (e.key) {
    // Ball #1 (arrows)
    case 'ArrowLeft':  balls[playerId].input.left  = isDown; break;
    case 'ArrowRight': balls[playerId].input.right = isDown; break;
    case 'ArrowUp':    balls[playerId].input.up    = isDown; break;
    case 'ArrowDown':  balls[playerId].input.down  = isDown; break;

    // Ball #2 (WASD)
    case 'a': case 'A': balls[1].input.left  = isDown; break;
    case 'd': case 'D': balls[1].input.right = isDown; break;
    case 'w': case 'W': balls[1].input.up    = isDown; break;
    case 's': case 'S': balls[1].input.down  = isDown; break;

  }
}


function applyJump() {
    const vel = playerBody.getLinearVelocity()
        .clone();
    vel.y += playerProperties.jumpVelocity;
    playerBody.setLinearVelocity(vel);
}



function syncAllBalls() {
  for (let { body, sprite } of balls) {
    const pos = body.GetPosition();
    sprite.x = convertTpuToPixels(pos.x);
    sprite.y = convertTpuToPixels(pos.y);
    sprite.rotation = body.GetAngle();
  }
}

function applyMovement() {
  for (let { body, input } of balls) {
    const v = body.GetLinearVelocity();
    let vx = v.x, vy = v.y;

    if (input.left  && vx > -playerProperties.maxSpeed) vx -= playerProperties.accel;
    if (input.right && vx <  playerProperties.maxSpeed) vx += playerProperties.accel;
    if (input.up    && vy > -playerProperties.maxSpeed) vy -= playerProperties.accel;
    if (input.down  && vy <  playerProperties.maxSpeed) vy += playerProperties.accel;

    body.SetLinearVelocity(new b2Vec2(vx, vy));
  }
}


//DUMMMM


function triggerExplosiona(bombBody, strength, radius) {
  const center = bombBody.GetPosition();
  const aabb = new b2AABB();
  aabb.lowerBound.Set(center.x - radius, center.y - radius);
  aabb.upperBound.Set(center.x + radius, center.y + radius);

  // query all fixtures in that box
  world.QueryAABB(function(fixture) {
    const body = fixture.GetBody();
    if (body.GetType() !== Box2D.Dynamics.b2Body.b2_dynamicBody) {
      return true; // keep going
    }

    const pos = body.GetPosition();
    const dx = pos.x - center.x;
    const dy = pos.y - center.y;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist > 0 && dist < radius) {
      const boost = strength * (radius - dist);
      const dir = new b2Vec2(dx / dist, dy / dist);

      const vel = body.GetLinearVelocity().Copy();
      vel.x += dir.x * boost;
      vel.y += dir.y * boost;
      body.SetLinearVelocity(vel);
    }

    return true; // continue query
  }, aabb);
}

function applyGravWell()
{
  


for(const ball of balls)
{

const ballPos = ball.body.GetPosition();

  for(const well of wells)
  {
    const wellPos = well.GetPosition();
    const dx = wellPos.x - ballPos.x;
    const dy = wellPos.y - ballPos.y;

    const distSq = dx*dx + dy *dy;

    if(distSq < 2.8 * 2.8)
  {
    const dist = Math.sqrt(distSq);
    const pull = 0.10 * (2.8-dist);
    const dir = new b2Vec2(dx / dist, dy / dist);



    const vel = ball.body.GetLinearVelocity().Copy();
    vel.x += dir.x * pull;
    vel.y += dir.y * pull;


    //const fx = (dx / dist) * forceMag;
    //const fy = (dy/dist ) * forceMag;

    //console.log(ball.body);
    ball.body.SetLinearVelocity(vel);

  }


  }


}


//   console.log(ballsGettingSuckedOff);
// for (let [key, value] of ballsGettingSuckedOff) {
//    // console.log(key + " is " + value);

//     var pos = key.GetPosition();
//     var dx = pos.x - value.x;
//     var dy = pos.y - value.y;
//     var dist = Math.sqrt(dx*dx + dy*dy);
//  console.log(dist)
//     if(dist < 7)
//     {
//     var pull = 0.0055 * (7-dist)

//     //console.log(pull)
//     var dir = new b2Vec2(dx / dist, dy/dist);

//     var vel = key.GetLinearVelocity().Copy();
//     vel.x += dir.x * pull;
//     vel.y+= dir.y * pull;

//     //console.log(key.GetPosition());
//     key.SetLinearVelocity(vel);
//     }



// }
}






function createBall(tpuX, tpuY, team) {
  const bodyDef = new b2BodyDef();
  bodyDef.type = b2Body.b2_dynamicBody;
  bodyDef.position.Set(tpuX, tpuY);
  bodyDef.linearDamping = playerProperties.linearDamping;
  bodyDef.angularDamping = playerProperties.angularDamping;

  const body = world.CreateBody(bodyDef);

  const fixDef = new b2FixtureDef();
  fixDef.shape = new b2CircleShape(playerProperties.radius);
  fixDef.density = playerProperties.density;
  fixDef.friction = playerProperties.friction;
  fixDef.restitution = playerProperties.restitution;

  const fixture = body.CreateFixture(fixDef);

  // Set userData correctly (you had quotes around the value "team")
  body.SetUserData({ type: 'ball', team: team });
  fixture.SetUserData({ type: 'ball', team: team, id: ballID });

  ballID++;
  // Choose sprite based on team
  let sprite;
  if (team === 'red') {
    sprite = new PIXI.Sprite(frameCache[35]);  // change frame index if needed
  } else if (team === 'blue') {
    sprite = new PIXI.Sprite(frameCache[36]);  // same here
  } else {
    sprite = new PIXI.Sprite(frameCache[0]);   // fallback/default sprite
  }

  sprite.anchor.set(0.5);
  foreground.addChild(sprite);

  // Add to ball tracking array
  balls.push({
    body,
    sprite,
    input: { left: false, right: false, up: false, down: false }
  });

  //console.log(balls);

  return { body, sprite };
}











function createAllPhysicsBodies() {
    const rows = globalMap.length;
    const cols = globalMap[0].length;

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const tileId = globalMap[row][col];
            if (!tileId) continue;
            const tile = tileData.find(t => t.id === tileId);
            if (!tile) continue;
            if (!tile.shape) continue;



            const size = parseFloat(tile.size || 40);
            const shape = tile.shape;
            const sensor = !!tile.sensor;
            const rotRad = parseFloat(tile.rotation || '0') * Math.PI / 180;
            const name = tile.name;


            createPhysicsBody(col, row, name, size, shape, sensor, rotRad);
        }
    }
}




  start(92050);
</script>
</body>
</html>
